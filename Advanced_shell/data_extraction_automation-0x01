#!/usr/bin/env bash

# This script extracts specific PokÃ©mon data from data.json
# and formats it using a pipeline of jq and awk.
# The final string is constructed using a template defined within the script.

# The script first checks if the data file exists.
if [ ! -f "data.json" ]; then
  echo "Error: data.json not found. Please run the API automation script first to create it." >&2
  exit 1
fi

# Define the template string with placeholders
TEMPLATE_STRING="$name is of type $type, weighs ${formatted_weight}kg, and is ${formatted_height}m tall."

# Pipeline command to extract, modify, and format the data.
# 1. jq extracts the raw values for name, type, weight, and height and
#    prints each on a new line. Weight and height are converted to kg and m.
# 2. awk reads the four lines of data, assigns them to variables, and
#    replaces the placeholders in the TEMPLATE_STRING with the actual values.
jq -r '.name, .types[0].type.name, (.weight / 10), (.height / 10)' data.json | \
awk -v template="$TEMPLATE_STRING" '
  BEGIN { # Capitalize the first letter of the name and type
    getline name < "/dev/stdin";
    name = toupper(substr(name, 1, 1)) substr(name, 2);
    getline type < "/dev/stdin";
    type = toupper(substr(type, 1, 1)) substr(type, 2);
    getline formatted_weight < "/dev/stdin";
    getline formatted_height < "/dev/stdin";
  }
  END {
    # Replace the placeholders in the template string
    gsub(/\$name/, name, template);
    gsub(/\$type/, type, template);
    gsub(/\$\{formatted_weight\}/, formatted_weight, template);
    gsub(/\$\{formatted_height\}/, formatted_height, template);
    
    # Print the final formatted string
    print template;
  }
'
